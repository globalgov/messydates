---
documentclass: jss
author:
  - name: James Hollway
    affiliation: |
      | Graduate Institute of
      | International and Development Studies
    # use this syntax to add text on several lines
    address: |
      | Chemin Eugène-Rigot 2A 
      | PO Box 1672 
      | 1211 Geneva 1 
      | Switzerland
    email: \email{james.hollway@graduateinstitute.ch}
    url: http://jameshollway.com
  - name: Henrique Sposito
    affiliation: |
      | Graduate Institute of
      | International and Development Studies
title:
  formatted: "Working with Unspecified, Approximate, Uncertain, Sets and Ranges of Dates with \\pkg{messydates}"
  # If you use tex in the formatted title, also supply version without
  plain: "Working with Unspecified, Approximate, Uncertain, Sets and Ranges of Dates with messydates"
  # For running headers, if needed
  short:     "\\pkg{messydates}: An R package for ISO's Extended Date/Time Format"
abstract: >
  This paper presents the \pkg{messydates} package for R, which facilitates working with 'messy' dates. 
  Messy dates are dates that include some imprecision and do not easily fit within the standard date format because they are historical,
  ambiguous, approximate, unspecified or uncertain,
  or otherwise admit of a range or set of possible dates.
  Messy dates are common when studying historical but also potentially current phenomena.
  Oftentimes, researchers will elect to pretend as if a messy date is more precise than it is to make it compatible with other more precise dates and to use various tools of temporal analysis such as event history analysis.
  The paper highlights these problems and offers practical advice on how to solve them using \pkg{messydates}. 
  The paper also introduces a conceptual framework for resolving messydates into more familiar date classes in R ready for analysis.
keywords:
  # at least one keyword must be supplied
  formatted: [dates, ISO, "\\proglang{R}"]
  plain:     [dates, ISO, R]
bib_file: 'references.bib'
preamble: >
  \usepackage{amsmath}
output: rticles::jss_article
bibliography: references.bib
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
options(prompt = 'R> ', continue = '+ ')
library(remotes)
remotes::install_github("globalgov/messydates", ref = "Develop")
library(lubridate)
library(anytime)
library(tibble)
library(dplyr)
library(stargazer)
```

# Introduction

<!-- define messydates up front -->

<!-- While there are several different -->

<!--Messy dates include some degree of imprecision such that existing -->

Dates are often messy.
Whether historical (or ancient), future, or even recent,
we sometimes only know approximately when an event occurred,
that it happened within a particular period,
or sources offer multiple competing dates.
Messy dates are dates that include some degree of imprecision.

<!-- introduce ISO details only as part of the solution? -->

\pkg{messydates} implements for R the Extended Date/Time Format (EDTF)
annotations set by the International Organization for Standardization (ISO) 
outlined in [ISO 8601-2_2019(E)](https://www.iso.org/standard/70908.html).
The extended format allows for standardised annotation of date imprecision so
interpretation is unambiguous and interoperability is guaranteed.
<!-- Add some quotes in from the ISO standard? -->
<!-- Maybe a quote from p. 8: -->
<!-- "Such concepts are often represented according to various ad-hoc conventions; -->
<!-- this document aims to provide a standard syntax for their representation. -->
<!-- The extended representations allow unambiguous interpretation, enforce the confidence of interoperability and minimize the risk of misinterpretations and their consequences." -->
These include notation for:

--------------------------------------------------------------------------------
 Date type           Annotation Example        Explanation
-----------------    ---------- -------------- ---------------------------------
unspecified          `X`        `2012-XX-01`   The first day of some unknown
date(component)s                               month

approximate          `~`        `2012-01-12~`  Approximately the 12th of
date(component)s                               January 2012

uncertain            `?`        `2012-01-12?`  The data point is based on an
date(component)s                               unreliable source

sets of dates        `{}`       `{2012-01-01,  Date can be either 1 January 2012
                                  2012-01-12}` and 12 January 2012
                                  
ranges of dates      `..`       `2012-01-01..  All dates between the 1 January
                                 2012-01-12`   2012 and 12 January 2012
--------------------------------------------------------------------------------

<!-- describe each of these dates first and when they might occur -->
<!-- -   unspecified date(component)s are annotated with "X", e.g. `2012-XX-01` for the first of some unknown month in 2012 -->
<!-- -   approximate date(component)s are annotated with "~", e.g. `2012-01-12~` for approximately the 12th of January 2012 -->
<!-- -   uncertain date(component)s are annotated with "?", e.g. `2012-01-12?` where this data point is based on an unreliable source -->
<!-- -   sets of dates are annotated with "{}", e.g. `{2012-01-01,2012-01-12}` where the date can be either 1 January 2012 and 12 January 2012 -->
<!-- -   ranges of dates are annotated with "..", e.g. `2012-01-01..2012-01-12` for all dates between the 1 January 2012 and 12 January 2012 inclusive -->
<!-- would a table work better to present these together? -->

\pkg{messydates} contains a set of tools for constructing and coercing dates into,
and from, the `mdate` S3 class.
The new date class allows regular dates to be annotated to express unspecified
date components, approximate or uncertain dates, date ranges, and sets of dates,
according to ISO standards.
The package also includes functions for expanding sets or ranges of
dates into all dates consistent with how the dates are specified or annotated.
Methods are offered that can be used to make explicit how researchers
convert date imprecision into precise dates for analysis,
such as getting the `min()`, `max()`, or even a `random()` date
from among the dates in a set or range of dates.
<!-- after introducing the class, then can introduce the ISO in more detail -->

<!-- talk about methods before novel functions, or vice versa? -->
<!-- The package includes functions for expanding sets or ranges of -->
<!-- dates into all dates consistent with how the date or set of dates -->
<!-- are specified or annotated. -->
<!-- Methods are also offered that can be used to make explicit how researchers -->
<!-- convert date imprecision into precise dates for analysis, -->
<!-- such as getting the `min()`, `max()`, or even a `random()` date -->
<!-- from among the dates in a set or range of dates. -->
<!-- This greatly facilitates research transparency and robustness checks -->
<!-- as we will demonstrate below. -->

## Motivation

Researchers often recognize date messiness, but feel required to
force non-existent precision on data so that they can proceed with analysis.
For example, if researchers know something happened in a given month or year,
they might opt for the start of that month (e.g. `2021-07-01`) or year (`2021`),
assuming that to err on the earlier (or later) side is a justifiable bias.
Or researchers might opt for the end of the time element because whatever
they believe happened at least is known to have happened by then.
However, this can create issues for inferences in which sequence or timing is important.
<!-- maybe unpack these issues here: e.g. what if one precise one messy date? what if not overlapping? maybe probabilistic first date happened then second date, but need to recognize this uncertainty. -->
The goal of \pkg{messydates} is to help researchers retain and
work with various kinds of date imprecision.

## Relationship to other packages

\pkg{messydates} offers a new date class,
but one that comes with methods for converting from and into `base`
date classes such as `Date`, `POSIXct`, and `POSIXlt`.
It is thus fully compatible with packages such as \pkg{lubridate} [@grolemundDatesTimesMade2011]
and \pkg{anytime} [@eddelbuettelAnytimeEasierDate2019].
<!-- when would users still want to use lubridate and anytime if they have messydates? -->
<!-- For specific date fuction, maybe handling time? Should we add that?-->
\pkg{messydates} is, therefore, compatible 
<!-- (perhaps with an additional coercion step) -->
with all contemporary R packages for analysis.
<!-- need to give examples of R packages that we know work with messydates now -->

# \proglang{R} code {#r-code short-title="R code"}

## Annotate

\pkg{messydates} contains a set of tools for constructing and
coercing into and from the `mdate` S3 class.
This date class implements ISO 8601-2:2019(E) and allows regular dates to be
annotated to express unspecified date components,
approximate or uncertain date components, date ranges, and sets of dates.
Inaccurate start or end dates can be represented by an affix
indicating "on or before", if used as a prefix (e.g. `..1816-01-01`),
or indicating "on or after", if used as a suffix (e.g. `2016-12-31..`).
Approximate date components are indicated by adding a `~` before year, month, or
day components (e.g. `2003-~03-03`) to estimate components that are possibly correct.
Approximate dates are indicated by adding a `~` after the date (e.g. `2003-03-03~`), 
Day, month, or year, uncertainty can be indicated by adding a `?` before a
specific date component (e.g. `?1916-10-10`).
Date uncertainty can be indicated by adding a `?` after the date (e.g. `1916-10-10?`).

```{r annotate, message=FALSE, warning=FALSE}
library(messydates)
tibble::tibble("Approximate date" = messydates::as_approximate(Sys.Date()), 
               "Uncertain date" = messydates::as_uncertain(Sys.Date()),
               "Censored (before)" = messydates::on_or_before(Sys.Date()),
               "Censored (after)" = messydates::on_or_after(Sys.Date()))
```

<!-- consider renaming 'on_or_after' as it doesn't fit the rest of the syntax. I thought maybe 'on_or_after' could be 'as_since()' and 'on_or_before' could be 'as_by()'? -->
<!-- I have no strong feeling about this, we can rename if you like to. -->
<!-- Perhaps another alternative is 'as_after()' and 'as_before()'. -->

## Coercion to messydates

The function `as_messydate()` handles the coercion to the `mdate` class in one step.
The coercion step automatically standardises separators, reorder components,
and adds annotations for ranges and sets of dates when needed.
<!-- do we need to say that we are using a universal/European date standard here, not e.g. an American one? -->
<!-- We are technically using the ISO "recommended" one,
so we might not need to be specific ...
Also, we often return dates that only have year or are missing components...-->
<!-- One more thing, I think we need a prettier table below,
but I am having issue transforming the table below into latex
in this rticles template. -->

```{r comparison, message=FALSE, warning=FALSE}
tibble::tribble(~Example, ~Date,
                "Normal date", as.character(Sys.Date()),
                "Future date", "9999-12-12",
                "DD/MM/YYYY", "31/10/2021",
                "Wrong date", "2021-31-10",
                "Historical date", "476",
                "Era date", "33 BC",
                "Unspecified date", "2012-01",
                "Range of dates", "2019-11-01:2020-01-01",
                "Set of dates", "2021-5-26, 2021-11-19, 2021-12-4",
                "Written date", "This is the first day of February, two thousand and twenty-one") %>%
  dplyr::mutate(base = as.Date(Date),
                lubridate = lubridate::as_date(Date),
                anytime = anytime::anydate(Date), #Do we need anytime?
                messydates = messydates::as_messydate(Date))
```

<!-- maybe divide this table up into date recognition and date annotation? -->

## Expand

The `expand()´ function transforms date ranges, sets of dates, and unspecified
or approximate dates (annotated with '..', '{ , }', or 'XX') into lists of dates.
As these dates may refer to several possible dates, the function "expands" these
shorthands to include all the possible dates implied.

```{r expand, message=FALSE, warning=FALSE}
dates_expand <- as_messydate(c("2001-01", "2001-01-01..2001-01-12",
                               "{2001-01-01,2001-02-01..2001-02-03}", "2001-XX-01"))
expand(dates_expand)
```

## Contract

The `contract()` function operates as the opposite of `expand()`.
It contracts a list of dates into their abbreviated annotations.
<!-- if multiple contractions are possible, e.g. range or set, it favours the most succinct/parsimonious representation? -->

```{r contract, warning=FALSE, message=FALSE}
tibble::tibble('Original Dates' = dates_expand,
               'Contracted Dates' = contract(expand(dates_expand)))
```

## Coercion from messydates

Coercion functions coerce objects of `mdate` class objects to common date classes
such as `Date`, `POSIXct`, and `POSIXlt`.
Since `mdate` objects can hold multiple individual dates,
an additional function must be passed as an argument so
that multiple dates are "resolved" into a single date.
For example, one might wish to use the earliest possible date
in a range, or set, of expanded dates (`min`),
or the latest possible date (`max`),
or some notion of a central tendency (`mean`, `median`, or `modal`),
or even a `random` selection from among the candidate dates.

```{r coerce, warning=FALSE, message=FALSE}
set.seed(1301)
tibble::tibble(Date = messydates::as_messydate("2001-01"),
               min = as.Date(Date, min),
               max = as.Date(Date, max),
               median = as.Date(Date, median),
               mean = as.Date(Date, mean),
               modal = as.Date(Date, modal),
               random = as.Date(Date, random))
```

## Additional functionality 

Several other functions are also offered in the \pkg{messydates} package.
For example, one can run various logical tests for checking `mdate` objects:

-   `is_messydate()` tests whether the object inherits the `mdate` class
-   `is_intersecting()` tests whether there is any intersection between two `mdate` objects
-   `is_element()` similarly tests whether an `mdate` can be found within an `mdate` range or set
<!-- does the former need to be precise? -->
<!-- Yes, the former must be precise. Should we try to change the function or be specific here? -->
-   `is_similar()` tests whether two `mdate` share one, or more, common components
-   `is_precise()` tests for whether `mdate` is precise

```{r logical, message=FALSE, warning=FALSE}
is_messydate(as_messydate("2001-01-01"))
is_intersecting(as_messydate("2001-01"), as_messydate("2001-02-01..2001-02-22"))
is_element(as_messydate("2001-01-01"), as_messydate("2001-01"))
is_similar(as_messydate("2001-06-02"), as_messydate("2001-02-06"))
is_precise(as_messydate("2001-02"))
```

Additionally, one can perform intersection (`md_intersect()`) and union (`md_union()`) on,
inter alia, messy date class objects.
<!-- do we need to explain why md_required? -->
<!-- I would not think so, but we can if you would like. -->
Or perform a 'join' that retains all elements, even if the result would contain duplicates,
with `md_multiset`.

```{r set, message=FALSE, warning=FALSE}
md_intersect(as_messydate("2001-01-01..2001-01-20"), as_messydate("2001-01"))
md_union(as_messydate("2001-01-01..2001-01-20"), as_messydate("2001-01"))
md_multiset(as_messydate("2001-01-01..2001-01-20"), as_messydate("2001-01"))
```

Certain arithmetic operations are available for messydates.
For instance, one can add, or subtract, a day (e.g. 1 or "1 day") or
one year (e.g. 365 or "1 year") to one, or all, `mdate` objects in a vector.

```{r operate, warning=FALSE, message=FALSE}
tibble::tibble(date = dates_expand,
               add = dates_expand + 1,
               subtract = dates_expand - "1 year")
```

<!-- talk about the syntax allowed with "1 year" etc -->

## Case Study - 2001 Battles

Dates, even for some recent events, can be messy.
Take the dates of battles in 2001 according to 
[Wikipedia](https://en.wikipedia.org/wiki/List_of_battles_in_the_21st_century),
retrieved on 2022-07-18, included in \pkg{messydates}.
<!-- cite and say when we retrieved this data -->
The dates of these battles are sometimes approximate
(i.e. the day in which a battle started or ended is unknown)
or come from unreliable sources (i.e. the date source might not be trustworthy).

```{r data, warning=FALSE, message=FALSE}
battles <- messydates::battles
battles$precise <- is_precise(battles$Date)
battles[, c("Battle", "Date", "precise")]
```

Getting the timing right can be important for researchers.
This is especially true if researchers are looking to generate robust inferences.
Until now, when faced with date imprecision, researchers usually have to choose
between making arbitrary choices (e.g. adding "-01-01" to year only dates)
or work with imprecise dates (e.g. year only).
Either choice may lead to biased results.
\pkg{messydates} facilitates working with these dates.
We can easily find the maximum length of the battles in in 2001.

<!-- need to motivate the following more beforehand. say we want to investigate conflict duration, or when battles start or so -->

```{r working with dates, warning=FALSE, message=FALSE}
battles$length <- as.Date(battles$Date, max) - as.Date(battles$Date, min)
battles[, c("Battle", "Date", "length")]
```

Assume we are interested in the relationship between the United States (US)
being a party to a conflict and the duration of the conflict in 2001.
We hypothesize that conflicts involving the US have
a shorter duration because of the US military capabilities.
Using \pkg{messydates} we create two different variables representing conflict
time from the 2001 battles data to be our dependent variables;
one variable with arbitrary cut off points and the other variable
<!-- but are these really 'arbitrary' cutoffs? they still represent a researcher decision, arguably a conscious one -->
with random values for uncertain or approximate dates.
Whether the US was involved in the conflict is our independent variable.
We also control for the number of actors involved in the conflict.
These variables are included in the 2001 battles data.
<!-- can we just add US party and n_actors to the original data to make the code below a little neater? -->
With these variables we run two simple linear regression models.

```{r lm, warning=FALSE, message=FALSE}
set.seed(1301)
battles <- battles %>%
  mutate(arbitrary = as.numeric(as.Date(Date, max) - as.Date(Date, min)),
         random = ifelse(is_uncertain(Date)|is_approximate(Date),
                         abs(as.Date(Date, random) - as.Date(Date, random)),
                         arbitrary))
arbitrary <- lm(arbitrary ~ US_party + N_actors, battles)
random <- lm(random ~ US_party + N_actors, battles)
stargazer::stargazer(arbitrary, random, type = "text")
```

Notice how the regression coefficients change and even flip signs in the two models.
Although not statistically significant, the coefficient for US being a party
in a conflict goes from being positive,
when calculated using arbitrary cut off dates, 
to being negative, when calculated using random dates.
In this case, setting arbitrary cut off points to dates introduces highly
influential outliers (see the Cook's distance plot below).
That is, these outlier observations drive coefficient scores up when,
in reality, we are not sure they accurately represent the timing.
<!-- explain the ramifications of that -->

```{r outliers, warning=FALSE, message=FALSE}
plot(lm(arbitrary ~ US_party + N_actors, battles), which = 4)
```

# Conclusion

<!-- need to add a stronger conclusion here -->
Dates are often messy.
Researchers recognize date messiness and, thanks to \pkg{messydates},
are no longer required to force non-existent precision on data to proceed with analysis.
\pkg{messydates} implements for R the 'mdate' class to help researchers
retain and work with various kinds of date imprecision.
The class allows regular dates to be annotated to express unspecified,
approximate or uncertain date components, date ranges, and sets of dates,
according to ISO standards.
\pkg{messydates} includes functions for expanding, and contracting,
annotated sets or ranges of dates.
Methods for explicitly resolving annotated sets or range of dates into
precise dates are also offered.

# Acknowledgements

We would like to thank the Swiss National Science Foundation. 
This work was supported by grant number 188976.

# References
