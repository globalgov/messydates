---
documentclass: jss
author:
  - name: James Hollway
    affiliation: |
      | Graduate Institute of
      | International and Development Studies
    # use this syntax to add text on several lines
    address: |
      | Chemin Eugène-Rigot 2A 
      | PO Box 1672 
      | 1211 Geneva 1 
      | Switzerland
    email: \email{james.hollway@graduateinstitute.ch}
    url: http://jameshollway.com
  - name: Henrique Sposito
    affiliation: |
      | Graduate Institute of
      | International and Development Studies
title:
  formatted: "Working with Missing, Approximate, Uncertain, Sets and Ranges of Dates with \\pkg{messydates}"
  # If you use tex in the formatted title, also supply version without
  plain:     "Working with Unspecified, Approximate, Uncertain, Sets and Ranges of Dates with messydates"
  # For running headers, if needed
  short:     "\\pkg{messydates}: An R package for ISO's Extended Date/Time Format"
abstract: >
  This paper presents the \pkg{messydates} package for R, which facilitates working with 'messy' dates. 
  Messy dates are common when studying historical and sometimes even current phenomena, 
  and can create various technical problems for the data analyst. 
  The paper highlights these problems and offers practical advice on how to solve them using \pkg{messydates}. 
  The paper also introduces a conceptual framework for resolving messydates into more familiar date classes in R ready for analysis.
keywords:
  # at least one keyword must be supplied
  formatted: [dates, ISO, "\\proglang{R}"]
  plain:     [dates, ISO, R]
bib_file: 'references.bib'
preamble: >
  \usepackage{amsmath}
output: rticles::jss_article
bibliography: references.bib
---

```{r, setup, include=FALSE}
options(prompt = 'R> ', continue = '+ ')
```

# Introduction

Dates are often messy. Whether historical (or ancient), future, or even recent, we often only know approximately when an event occurred, that it happened within a particular period, an unreliable source means a date should be flagged as uncertain, or sources offer multiple, competing dates.

\pkg{messydates} implements the extended annotation standard for dates, the Extended Date/Time Format (EDTF), outlined in [ISO 8601-2_2019(E)](https://www.iso.org/standard/70908.html) for R. These include standardised notation for:

-   unspecified date( component)s, e.g. `2012-XX-01` for the first of some unknown month in 2012 or 2012-01 for some unknown day in January 2012
-   approximate date( component)s, e.g. `2012-01-12~` for approximately the 12th of January 2012
-   uncertain date( component)s, e.g. `2012-01-12?` where this data point is based on an unreliable source
-   sets of dates, e.g. `{2012-01-01,2012-01-12}` where the date can be both 1 January 2012 and 12 January 2012
-   ranges of dates, e.g. `2012-01-01..2012-01-12` for all dates between the 1 January 2012 and 12 January 2012 inclusive

\pkg{messydates} contains a set of tools for constructing and coercing into and from the `mdate` class. This date class allows regular dates to be annotated to express unspecified date components, approximate or uncertain date components, date ranges, and sets of dates.

Importantly, the package also includes a function for unpacking or expanding sets or ranges of dates into all dates consistent with how the date or set of dates is specified or annotated. Methods are also offered that can be used to make explicit how researchers convert date imprecision into precise dates for analysis, such as getting the `min()`, `max()`, or even a `random()` date from among the dates consistent with a set or range of dates. This greatly facilitates research transparency as well as robustness checks.

## Motivation

As researchers, we often recognize this messiness but are forced to force non-existent precision on data so we can proceed with analysis. For example, if we only know something happened in a given month or year, we might just opt for the start of that month (e.g. `2021-07-01`) or year (`2021-01-01`), assuming that to err on the earlier (or later) side is a justifiable bias. However, this can create issues for inference in which sequence or timing is important. The goal of \pkg{messydates} is to help with this problem by retaining and working with various kinds of date imprecision.

## Relationship to other packages

\pkg{messydates} offers a new date class, but one that comes with methods for converting from and into common date classes such as `Date`, `POSIXct`, and `POSIXlt.` It is thus fully compatible with packages such as \pkg{lubridate} [@grolemundDatesTimesMade2011] and \pkg{anytime} [@eddelbuettelAnytimeEasierDate2019].

# \proglang{R} code {#r-code short-title="R code"}

## A new class

\pkg{messydates} contains a set of tools for constructing and coercing into and from the `mdate` class. This date class implements ISO 8601-2:2019(E) and allows regular dates to be annotated to express unspecified date components, approximate or uncertain date components, date ranges, and sets of dates. The function `as_messydate()` handles the coercion to `mdate` class.

```{r comparison, warning=FALSE}
library(messydates)
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(anytime))
library(tibble)
suppressPackageStartupMessages(library(dplyr))
dates_comparison <- tibble::tribble(~Example, ~OriginalDate,
                                    "A normal date", as.character(Sys.Date()),
                                    "A future date", "2599-12-31",
                                    "A written date", "First of February, two thousand and twenty-one",
                                    "A historical date", "476",
                                    "An era date", "33 BC",
                                    "An approximate date", "2012-01-12~",
                                    "An uncertain date", "2001-01-01?",
                                    "An unspecified date", "2012-01",
                                    "A censored date", "..2012-01-12", 
                                    "A range of dates", "2019-11-01:2020-01-01",
                                    "A set of dates", "2021-5-26, 2021-11-19, 2021-12-4") %>%
  dplyr::mutate(base = as.Date(OriginalDate),
                lubridate = lubridate::as_date(OriginalDate),
                anytime = anytime::anydate(OriginalDate),
                messydates = messydates::as_messydate(OriginalDate)) %>%
  print()
```

## Annotate

Some datasets have, for example, an arbitrary cut off point for start and end points, but these are often coded as precise dates when they are not necessarily the real start or end dates. The annotate functions helps annotate uncertainty and approximation to dates. Inaccurate start or end dates can be represented by an affix indicating "on or before", if used as a prefix (e.g. `..1816-01-01`), or indicating "on or after", if used as a suffix (e.g. `2016-12-31..`). Approximate dates are indicated by adding a `~` to year, month, or day components, as well as groups of components or whole dates to estimate values that are possibly correct (e.g. `2003-03-03~`). Day, month, or year, uncertainty can be indicated by adding a `?` to a possibly dubious date (e.g. `1916-10-10?`) or date component (e.g. `1916-?10-10`).

```{r annotate, warning=FALSE}
dates_annotate <- tibble::tibble(Beg = as_messydate(c("1816-01-01", "1916-01-01", "2016-01-01")),
                                 End = as_messydate(c("1816-12-31", "1916-12-31", "2016-12-31")))
dplyr::mutate(dates_annotate, Beg = ifelse(Beg <= "1816-01-01", on_or_before(Beg), Beg))
dplyr::mutate(dates_annotate, End = ifelse(End >= "2016-01-01", on_or_after(End), End))
dplyr::mutate(dates_annotate, Beg = ifelse(Beg == "1916-01-01", as_approximate(Beg), Beg))
dplyr::mutate(dates_annotate, End = ifelse(End == "1916-12-31", as_uncertain(End), End))
```

## Expand

Expand functions transform date ranges, sets of dates, and unspecified or approximate dates (annotated with '..', '{ , }', 'XX' or '\~') into lists of dates. As these dates may refer to several possible dates, the function "opens" these values to include all the possible dates implied.

```{r expand, warning=FALSE}
dates_expand <- as_messydate(c("2001-01-01", "2001-01?", "2001",
                               "2001-01-01..2001-02-02", "{2001-01-01,2001-02-02}",
                               "2001-XX-31", "21 BC"))
expand(dates_expand)
```

## Contract

The `contract()` function operates as the opposite of `expand()`. It contracts a list of dates into the abbreviated annotation of \pkg{messydates}.

```{r contract, warning=FALSE, message=FALSE}
tibble::tibble(contract = contract(expand(dates_expand)))
```

## Coerce from messydates

Coercion functions coerce objects of `mdate` class to common date classes such as `Date`, `POSIXct`, and `POSIXlt`. Since `mdate` objects can hold multiple individual dates, an additional function must be passed as an argument so that multiple dates are "resolved" into a single date.

For example, one might wish to use the earliest possible date in any ranges of dates (`min`), the latest possible date (`max`), some notion of a central tendency (`mean`, `median`, or `modal`), or even a `random` selection from amongst the candidate dates.

These functions are particularly useful for use with existing methods and models, especially for checking the robustness of results.

```{r coerce, warning=FALSE, message=FALSE}
tibble::tibble(min = as.Date(dates_expand, min),
               max = as.Date(dates_expand, max),
               median = as.Date(dates_expand, median),
               mean = as.Date(dates_expand, mean),
               modal = as.Date(dates_expand, modal),
               random = as.Date(dates_expand, random))
```

## Additional functionality 

Several other functions are also offered in the \pkg{messydates} package.

For example, one can check various logical tests for messy date objects. `is_messydate()` tests whether the object inherits the `mdate` class. `is_intersecting()` tests whether there is any intersection between two messy dates. `is_element()` similarly tests whether a messy date can be found within a messy date range or set. `is_similar()` tests whether two dates contain similar components. `is_precise()` tests for whether date is precise.

```{r logical, warning=FALSE}
is_messydate(as_messydate("2001-01-01"))
is_messydate(as.Date("2001-01-01"))
is_intersecting(as_messydate("2001-01"), as_messydate("2001-01-01..2001-02-22"))
is_intersecting(as_messydate("2001-01"), as_messydate("2001-02-01..2001-02-22"))
is_element(as_messydate("2001-01-01"), as_messydate("2001-01"))
is_element(as_messydate("2001-01-01"), as_messydate("2001-02"))
is_similar(as_messydate("2001-06-02"), as_messydate("2001-02-06"))
is_similar(as_messydate("2001-06-22"), as_messydate("2001-02-06"))
is_precise(as_messydate("2001-06-02"))
is_precise(as_messydate("2001-02"))
```

Additionally, one can perform intersection (`md_intersect()`) and union (`md_union()`) on, inter alia, messy date class objects. Or 'join' that retains all elements, even if duplicated, with `md_multiset`.

```{r set, warning=FALSE}
md_intersect(as_messydate("2001-01-01..2001-01-20"),as_messydate("2001-01"))
md_union(as_messydate("2001-01-01..2001-01-20"),as_messydate("2001-01"))
md_multiset(as_messydate("2001-01-01..2001-01-20"),as_messydate("2001-01"))
```

As well, some arithmetic operations are available for messydates. For instance, one can add or subtract one year to all messy dates in a vector.

```{r operate, warning=FALSE, message=FALSE}
tibble::tibble(date = dates_expand, add = dates_expand + "1 day", subtract = dates_expand - "1 year")
```

## Case Study - 2001 Battles

Dates, even for some recent events, can be messy. Take, for example, the dates of battles in 2001 according to [Wikipedia](https://en.wikipedia.org/wiki/List_of_battles_in_the_21st_century).
The dates of these battles are often uncertain, with different levels of date precision being reported. \pkg{messydates} facilitates working with these dates.

```{r data, warning=FALSE, message=FALSE}
battles <- tibble::tribble(~Battle, ~Date, ~Parties,
                           "Operation MH-2", "2001 March 8", "MK-National Libration Army(MK)",
                           "2001 Bangladesh–India border clashes", "2001-04-16..2001-04-20", "BD-ID",
                           "Operation Vaksince", "25-5-2001", "MK-National Libration Army(MK)",
                           "Alkhan-Kala operation", "2001-6-22..2001-6-28", "RU-Chechen Republic",
                           "Battle of Vedeno", "2001-8-13..2001-8-26", "RU-Chechen Insurgents", 
                           "Operation Crescent Wind", "2001-10-7..2001-12?", "US/UK-Taliban",
                           "Operation Rhino", "2001-10-19..2001-10-20", "US-Taliban",
                           "Battle of Mazar-e-Sharif","2001-11-9", "US/Northern Alliance-Taliban/al-Qaeda", 
                           "Siege of Kunduz", "2001-11-11..2001-11-23", "US/Northern Alliance-Taliban/al-Qaeda",
                           "Battle of Herat", "Twelve of November of two thousand and twenty-one", "US/Northern Alliance/Iran-Taliban", 
                           "Battle of Kabul", "2001-11-13..2001-11-14", "US/Northern Alliance-Taliban",
                           "Battle of Tarin Kowt", "2001-11-13:2001-11-14", "US/Eastern Alliance-Taliban",
                           "Operation Trent", "2001-11-~15..2001-11-~30", "US/UK-Taliban/al-Qaeda",
                           "Battle of Kandahar", "2001-11-22..2001-12-07", "US/AU/Eastern Alliance-Taliban",
                           "Battle of Qala-i-Jangi", "2001-11-25:2001-12-01", "US/UK/Northern Alliance-Taliban/al-Qaeda",
                           "Battle of Tora Bora", "2001-12-12..2001-12-17", "US/Northern Alliance-Taliban/al-Qaeda",
                           "Battle of Shawali Kowt", "2001-12-3", "US/Eastern Alliance-Taliban",
                           "Battle of Sayyd Alma Kalay", "2001-12-4", "US/Eastern Alliance-Taliban",
                           "Battle of Amami-Oshima", "2001-12-22", "JP-KP",
                           "Tsotsin-Yurt operation", "2001-12-30:2002-01-03", "RU-Chechen Insurgents")
battles$Date = as_messydate(battles$Date)
tibble::tibble(battles)
```

Getting the timing can be important for researchers, however, when faced with date imprecision, researchers usually have to chose between making arbitrary choices (e.g. adding "-01-01" to all incomplete dates) or work imprecise dates (i.e. year only). Yet, both choices may lead to bias results. This is especially true if researchers' are looking to generate inferences where getting "timing" right is important.

Assume, for example, certain researcher is interested in the relationship between the United States (US) being a party in a conflict and the duration of the conflict in 2001. The researcher might theorize that conflicts involving the US have a shorter duration since the US has the most powerful military in the world. As well, this is relationship could be mediated by the number of parties involved in the conflict. That is, the number of actors involved in a conflict could have an effect on conflict time. Using \pkg{messydates}, we can create two different date variables in the battles data to represent conflict time, one with an arbitrary cut of point (difference between the minimal and maximal values) and the other with random values (difference between two random values in the range for uncertain or approximate dates). These will be our dependent variables. We can also create a dummy variable for whether the US was, or not, involved in the conflict to be our main independent variable. As a control, we also code the number of actors in the conflict. With these variables in hand, we build two linear regression models correlating each of the dependent variables to conflict time.

```{r case study, warning=FALSE, message=FALSE}
set.seed(3333)
battles <- battles %>%
  mutate(arbitrary = as.numeric(as.Date(Date, max) - as.Date(Date, min)),
         random = ifelse(grepl("\\?|\\~", Date),
                         abs(as.Date(Date, random) - as.Date(Date, random)),
                         arbitrary),
         US_party = ifelse(grepl("US", Parties), 1, 0),
         n_actors = c(2, 2, 2, 2, 2, 3, 2, 4, 4, 4, 3, 3, 4, 4, 5, 4, 3, 3, 2, 2))
arbitrary <- lm(arbitrary ~ US_party + n_actors, battles)
random <- lm(random ~ US_party + n_actors, battles)
library(stargazer)
stargazer::stargazer(arbitrary, random, type = "text")
```

Notice how the regression coefficients change when we pick random values within the range for the uncertain and approximate dates in the battles data, in comparison to setting arbitrary cut off points. Although not statistically significant, the coefficient for US being a party in a conflict goes from being positive when we use arbitrary cut off points for uncertain dates, to negative when we we use random values within that range. In this case, it is hard to say whether the relationship between the US being a part of a battle in 2001 and the time of the conflict is positive or not.

# Acknowledgements

We would like to thank the Swiss National Science Foundation. 
This work was supported by grant number 188976.

# References
